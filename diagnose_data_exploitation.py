#!/usr/bin/env python
"""
Script de diagnostic pour identifier les obstacles √† l'exploitation des donn√©es TFT
"""

import os
import sys
import django
from datetime import datetime, date

# Configuration Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'fr_backend.settings')
django.setup()

from api.reports.models import AccountData, BalanceUpload, GeneratedFile
from api.reports.tft_generator import generate_tft_and_sheets_from_database

def check_data_quality():
    """V√©rifie la qualit√© des donn√©es"""
    
    print("üîç DIAGNOSTIC DE LA QUALIT√â DES DONN√âES")
    print("=" * 60)
    
    # 1. V√©rifier la pr√©sence de donn√©es
    total_accounts = AccountData.objects.count()
    print(f"üìä Total enregistrements AccountData: {total_accounts}")
    
    if total_accounts == 0:
        print("‚ùå PROBL√àME MAJEUR: Aucune donn√©e AccountData")
        return False
    
    # 2. V√©rifier les financial_report_ids
    financial_report_ids = AccountData.objects.values_list('financial_report_id', flat=True).distinct()
    financial_report_ids = [fid for fid in financial_report_ids if fid]
    print(f"üìä Financial Report IDs: {len(financial_report_ids)}")
    
    if not financial_report_ids:
        print("‚ùå PROBL√àME: Aucun financial_report_id valide")
        return False
    
    # 3. Analyser les exercices
    exercices = set()
    for data in AccountData.objects.all():
        exercices.add(data.created_at.year)
    
    exercices = sorted(exercices)
    print(f"üìÖ Exercices disponibles: {exercices}")
    
    if len(exercices) == 0:
        print("‚ùå PROBL√àME: Aucun exercice d√©tect√©")
        return False
    
    # 4. V√©rifier la coh√©rence des donn√©es
    print(f"\nüîç V√âRIFICATION DE LA COH√âRENCE:")
    
    # V√©rifier les colonnes requises
    required_fields = ['account_number', 'balance', 'total_debit', 'total_credit', 'created_at']
    sample_data = AccountData.objects.first()
    
    for field in required_fields:
        if hasattr(sample_data, field):
            print(f"   ‚úÖ {field}: Pr√©sent")
        else:
            print(f"   ‚ùå {field}: Manquant")
    
    # V√©rifier les valeurs nulles
    null_balances = AccountData.objects.filter(balance__isnull=True).count()
    null_accounts = AccountData.objects.filter(account_number__isnull=True).count()
    
    print(f"   üìä Comptes avec balance nulle: {null_balances}")
    print(f"   üìä Comptes avec num√©ro nul: {null_accounts}")
    
    # 5. Analyser la distribution des montants
    print(f"\nüìä ANALYSE DES MONTANTS:")
    
    # Calculer le total des soldes de mani√®re s√©curis√©e
    total_balance = 0
    for account in AccountData.objects.all()[:100]:  # Limiter pour √©viter les erreurs
        try:
            if account.balance and isinstance(account.balance, (int, float)):
                total_balance += float(account.balance)
        except (TypeError, ValueError):
            continue
    
    print(f"   Total des soldes (√©chantillon): {total_balance:,.2f}")
    
    positive_balances = AccountData.objects.filter(balance__gt=0).count()
    negative_balances = AccountData.objects.filter(balance__lt=0).count()
    zero_balances = AccountData.objects.filter(balance=0).count()
    
    print(f"   Soldes positifs: {positive_balances}")
    print(f"   Soldes n√©gatifs: {negative_balances}")
    print(f"   Soldes z√©ro: {zero_balances}")
    
    return True

def check_tft_calculation_issues():
    """V√©rifie les probl√®mes de calcul TFT"""
    
    print(f"\nüßÆ DIAGNOSTIC DES CALCULS TFT")
    print("=" * 60)
    
    # R√©cup√©rer un financial_report_id pour test
    financial_report_ids = AccountData.objects.values_list('financial_report_id', flat=True).distinct()
    financial_report_ids = [fid for fid in financial_report_ids if fid]
    
    if not financial_report_ids:
        print("‚ùå Aucun financial_report_id disponible")
        return False
    
    financial_report_id = financial_report_ids[0]
    
    try:
        # D√©terminer les dates
        account_data = AccountData.objects.filter(financial_report_id=financial_report_id)
        exercices = set()
        for data in account_data:
            exercices.add(data.created_at.year)
        
        exercices = sorted(exercices)
        
        if len(exercices) >= 2:
            n_1 = exercices[-2]
            n = exercices[-1]
            start_date = date(n_1, 1, 1)
            end_date = date(n, 12, 31)
        elif len(exercices) == 1:
            n = exercices[0]
            start_date = date(n, 1, 1)
            end_date = date(n, 12, 31)
        else:
            print("‚ùå Aucun exercice d√©tect√©")
            return False
        
        print(f"üìÖ P√©riode TFT: {start_date} √† {end_date}")
        
        # G√©n√©rer le TFT
        tft_content, sheets_contents, tft_data, sheets_data, coherence = generate_tft_and_sheets_from_database(
            financial_report_id, start_date, end_date
        )
        
        print(f"‚úÖ TFT g√©n√©r√© avec succ√®s")
        
        # Analyser les rubriques vides
        print(f"\nüîç RUBRIQUES VIDEES OU PROBL√âMATIQUES:")
        
        empty_rubriques = []
        problematic_rubriques = []
        
        for ref, data in tft_data.items():
            if isinstance(data, dict) and 'montant' in data:
                montant = data['montant']
                if montant is None:
                    problematic_rubriques.append(f"{ref}: None")
                elif abs(montant) < 0.01:
                    empty_rubriques.append(f"{ref}: {montant:.2f}")
        
        if empty_rubriques:
            print(f"   üìä Rubriques vides (< 0.01): {len(empty_rubriques)}")
            for rubrique in empty_rubriques[:10]:  # Afficher les 10 premi√®res
                print(f"      - {rubrique}")
        
        if problematic_rubriques:
            print(f"   ‚ùå Rubriques probl√©matiques (None): {len(problematic_rubriques)}")
            for rubrique in problematic_rubriques[:10]:
                print(f"      - {rubrique}")
        
        # V√©rifier la coh√©rence
        print(f"\nüîç COH√âRENCE TFT:")
        print(f"   Coh√©rent: {coherence.get('is_coherent', 'N/A')}")
        
        if not coherence.get('is_coherent', False):
            print(f"   ‚ö†Ô∏è  TFT non coh√©rent - v√©rification n√©cessaire")
            if 'details' in coherence:
                details = coherence['details']
                variation_tft = details.get('flux_operationnels', 0) + details.get('flux_investissement', 0) + details.get('flux_financement', 0)
                variation_treso = details.get('treso_cloture', 0) - details.get('treso_ouverture', 0)
                print(f"      Variation TFT: {variation_tft:,.2f}")
                print(f"      Variation Tr√©sorerie: {variation_treso:,.2f}")
                print(f"      √âcart: {abs(variation_tft - variation_treso):,.2f}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur lors de la g√©n√©ration TFT: {str(e)}")
        import traceback
        traceback.print_exc()
        return False

def check_mapping_issues():
    """V√©rifie les probl√®mes de mapping des comptes"""
    
    print(f"\nüó∫Ô∏è DIAGNOSTIC DES MAPPINGS")
    print("=" * 60)
    
    # V√©rifier les comptes non mapp√©s
    all_accounts = set(AccountData.objects.values_list('account_number', flat=True))
    
    # Comptes SYSCOHADA standard
    syscohada_accounts = {
        'Tr√©sorerie': ['501', '502', '503', '504', '505', '506', '521', '522', '523', '524', '531', '532', '533', '541', '542', '561', '564', '565'],
        'Capitaux propres': ['101', '103', '104', '105', '106', '108', '109', '110', '130', '131'],
        'Immobilisations': ['201', '203', '204', '205', '208', '211', '212', '213', '214', '215', '218', '237', '238', '251', '256', '261', '262', '264', '265', '266', '267', '268', '269', '274', '275'],
        'Stocks': ['311', '321', '322', '323', '331', '335', '341', '345', '351', '358', '39'],
        'Cr√©ances': ['411', '416', '417', '418', '419', '491'],
        'Dettes': ['401', '402', '403', '408', '409', '419', '421', '422', '423', '424', '425', '43', '447', '441', '442', '443', '444', '445', '446', '447', '448', '449', '161', '162', '163', '164', '165', '168'],
        'Produits': ['701', '702', '703', '704', '705', '706', '707', '708', '761', '762', '763', '764', '767', '781'],
        'Charges': ['601', '602', '603', '604', '605', '606', '607', '608', '661', '662', '663', '664', '665', '666', '667', '668', '631', '633', '635', '675', '681', '682', '683', '684', '685', '686', '687', '688', '689', '691', '692', '693', '694', '695', '696', '697', '698', '699', '775', '781', '782', '783', '784', '785', '786', '787', '788', '789', '791', '792', '793', '794', '795', '796', '797', '798', '799']
    }
    
    # Flatten all SYSCOHADA accounts
    all_syscohada_accounts = set()
    for category, accounts in syscohada_accounts.items():
        all_syscohada_accounts.update(accounts)
    
    # Trouver les comptes non mapp√©s
    unmapped_accounts = all_accounts - all_syscohada_accounts
    
    print(f"üìä Comptes dans les donn√©es: {len(all_accounts)}")
    print(f"üìä Comptes SYSCOHADA standard: {len(all_syscohada_accounts)}")
    print(f"üìä Comptes non mapp√©s: {len(unmapped_accounts)}")
    
    if unmapped_accounts:
        print(f"\n‚ö†Ô∏è  COMPTES NON MAPP√âS (premiers 20):")
        for account in sorted(list(unmapped_accounts))[:20]:
            # V√©rifier le solde
            balance = AccountData.objects.filter(account_number=account).aggregate(total=sum('balance'))['total'] or 0
            print(f"   {account}: {balance:,.2f}")
    
    # V√©rifier les comptes avec des soldes significatifs non mapp√©s
    significant_unmapped = []
    for account in unmapped_accounts:
        balance = AccountData.objects.filter(account_number=account).aggregate(total=sum('balance'))['total'] or 0
        if abs(balance) > 1000:  # Seuil significatif
            significant_unmapped.append((account, balance))
    
    if significant_unmapped:
        print(f"\n‚ö†Ô∏è  COMPTES NON MAPP√âS AVEC SOLDES SIGNIFICATIFS:")
        for account, balance in sorted(significant_unmapped, key=lambda x: abs(x[1]), reverse=True)[:10]:
            print(f"   {account}: {balance:,.2f}")

def check_system_issues():
    """V√©rifie les probl√®mes syst√®me"""
    
    print(f"\n‚öôÔ∏è DIAGNOSTIC SYST√àME")
    print("=" * 60)
    
    # V√©rifier les migrations
    from django.db import connection
    with connection.cursor() as cursor:
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='account_data'")
        table_exists = cursor.fetchone()
    
    if table_exists:
        print("‚úÖ Table account_data existe")
    else:
        print("‚ùå Table account_data manquante")
    
    # V√©rifier les permissions
    try:
        AccountData.objects.count()
        print("‚úÖ Acc√®s en lecture √† AccountData")
    except Exception as e:
        print(f"‚ùå Probl√®me d'acc√®s √† AccountData: {e}")
    
    # V√©rifier l'espace disque
    import shutil
    total, used, free = shutil.disk_usage(".")
    print(f"üìä Espace disque: {free // (1024**3)} GB libres")
    
    # V√©rifier la m√©moire
    import psutil
    memory = psutil.virtual_memory()
    print(f"üìä M√©moire: {memory.percent}% utilis√©e, {memory.available // (1024**3)} GB libres")

def main():
    """Fonction principale"""
    print("üîç DIAGNOSTIC COMPLET - OBSTACLES √Ä L'EXPLOITATION DES DONN√âES")
    print("=" * 80)
    
    # 1. V√©rifier la qualit√© des donn√©es
    data_ok = check_data_quality()
    
    if not data_ok:
        print("\n‚ùå ARR√äT: Probl√®mes majeurs de donn√©es d√©tect√©s")
        return
    
    # 2. V√©rifier les calculs TFT
    tft_ok = check_tft_calculation_issues()
    
    # 3. V√©rifier les mappings
    check_mapping_issues()
    
    # 4. V√©rifier le syst√®me
    check_system_issues()
    
    # 5. Recommandations
    print(f"\nüí° RECOMMANDATIONS POUR AM√âLIORER L'EXPLOITATION:")
    print("-" * 60)
    
    print("1. üìä Donn√©es:")
    print("   - V√©rifier la coh√©rence des exercices")
    print("   - S'assurer que tous les comptes importants sont pr√©sents")
    
    print("2. üó∫Ô∏è Mappings:")
    print("   - Ajouter les comptes non mapp√©s avec des soldes significatifs")
    print("   - V√©rifier les pr√©fixes de comptes")
    
    print("3. üßÆ Calculs:")
    print("   - Corriger la coh√©rence TFT si n√©cessaire")
    print("   - V√©rifier les formules de calcul")
    
    print("4. ‚öôÔ∏è Syst√®me:")
    print("   - Surveiller l'espace disque et la m√©moire")
    print("   - Optimiser les requ√™tes si n√©cessaire")

if __name__ == "__main__":
    main()
